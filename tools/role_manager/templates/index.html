<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Discord Role Manager v2</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
</head>

<body>
    <div class="container">
        <header>
            <h1>üõ†Ô∏è Qu·∫£n L√Ω Role (Ph√¢n M·ª•c)</h1>
            <div class="controls">
                <button id="add-category-btn" class="btn btn-secondary">‚ûï Th√™m Ph√¢n M·ª•c</button>
                <button id="save-btn" class="btn btn-primary" disabled>üíæ L∆∞u C·∫•u Tr√∫c</button>
                <button id="refresh-btn" class="btn btn-secondary">üîÑ L√†m M·ªõi</button>
            </div>
            <p id="status-msg"></p>
        </header>

        <div id="loading" class="loading">ƒêang t·∫£i c·∫•u tr√∫c role...</div>

        <!-- Main Container for Categories -->
        <div id="category-container" class="category-list">
            <!-- Categories will be injected here -->
        </div>
    </div>

    <!-- Edit Modal -->
    <div id="edit-modal" class="modal">
        <div class="modal-content">
            <h3>Ch·ªânh s·ª≠a Role</h3>
            <label>T√™n Role:</label>
            <input type="text" id="edit-name" />
            <label>M√†u (Decimal):</label>
            <div class="color-picker-wrapper">
                <input type="color" id="edit-color-picker">
                <input type="number" id="edit-color-decimal" placeholder="Decimal Color">
            </div>
            <div class="modal-actions">
                <button id="modal-cancel">H·ªßy</button>
                <button id="modal-save" class="btn-primary">L∆∞u</button>
            </div>
        </div>
    </div>

    <script>
        // State
        const categoryContainer = document.getElementById('category-container');
        const saveBtn = document.getElementById('save-btn');
        const refreshBtn = document.getElementById('refresh-btn');
        const addCatBtn = document.getElementById('add-category-btn');
        const statusMsg = document.getElementById('status-msg');
        const loading = document.getElementById('loading');

        // Modal Elements
        const modal = document.getElementById('edit-modal');
        const editName = document.getElementById('edit-name');
        const editColorDecimal = document.getElementById('edit-color-decimal');
        const editColorPicker = document.getElementById('edit-color-picker');
        let currentEditingRoleId = null;

        // Draft Mode State
        // Map: roleId -> {name, color, originalName, originalColor}
        const pendingUpdates = new Map();
        let hasReorderChanges = false;

        // Fetch Data
        async function fetchRoles() {
            loading.style.display = 'block';
            categoryContainer.innerHTML = '';
            statusMsg.textContent = '';
            pendingUpdates.clear(); // Clear drafts on refresh
            hasReorderChanges = false;
            updateSaveButtonState();

            try {
                const res = await fetch('/api/roles');
                const categories = await res.json();

                if (categories.error) {
                    showStatus(categories.error, true);
                    return;
                }

                renderCategories(categories);
                loading.style.display = 'none';
            } catch (err) {
                console.error(err);
                showStatus('‚ùå Kh√¥ng th·ªÉ t·∫£i danh s√°ch Role. K·∫øt n·ªëi th·∫•t b·∫°i.', true);
                loading.textContent = "L·ªói k·∫øt n·ªëi. Vui l√≤ng refresh.";
            }
        }

        function renderCategories(categories) {
            categoryContainer.innerHTML = '';

            categories.forEach(cat => {
                const catDiv = document.createElement('div');
                catDiv.className = 'category-card';
                catDiv.dataset.id = cat.id;
                catDiv.dataset.isReal = cat.is_real_category;

                const header = document.createElement('div');
                header.className = 'category-header';
                let headerContent = `
                    <div class="cat-title">
                        <span class="drag-handle">‚ò∞</span>
                        <button class="toggle-btn" data-cat-id="${cat.id}">‚ñº</button>
                        <span class="cat-name" style="color:${intToHex(cat.color)}">${cat.name}</span>
                    </div>
                    <div class="cat-actions">
                        ${cat.is_real_category ? `<button class="btn-icon edit-role-btn" data-id="${cat.id}" data-name="${cat.name}" data-color="${cat.color}">‚úèÔ∏è</button>` : ''}
                        <button class="btn-small add-role-btn" data-cat-id="${cat.id}">‚ûï Role</button>
                    </div>
                `;
                header.innerHTML = headerContent;
                catDiv.appendChild(header);

                const roleList = document.createElement('ul');
                roleList.className = 'role-list';
                roleList.dataset.catId = cat.id;

                cat.roles.forEach(role => {
                    const li = createRoleElement(role);
                    roleList.appendChild(li);
                });

                catDiv.appendChild(roleList);
                categoryContainer.appendChild(catDiv);

                new Sortable(roleList, {
                    group: 'roles',
                    animation: 150,
                    ghostClass: 'sortable-ghost',
                    onEnd: onDragEnd
                });
            });

            new Sortable(categoryContainer, {
                animation: 150,
                handle: '.drag-handle',
                ghostClass: 'sortable-ghost',
                onEnd: onDragEnd
            });

            attachDynamicEvents();
        }

        function createRoleElement(role) {
            const li = document.createElement('li');
            li.className = 'role-item';
            li.dataset.id = role.id;
            li.dataset.name = role.name;
            li.dataset.color = role.color;

            // Check if pending changes exist
            if (pendingUpdates.has(role.id)) {
                const update = pendingUpdates.get(role.id);
                if (update.name) role.name = update.name;
                if (update.color) role.color = update.color;
                li.classList.add('pending-change'); // Visual indicator?
            }

            li.innerHTML = `
                <span class="role-color" style="background-color:${intToHex(role.color)}"></span>
                <span class="role-name">${role.name} ${pendingUpdates.has(role.id) ? '*' : ''}</span>
                <button class="btn-icon edit-role-btn" data-id="${role.id}" data-name="${role.name}" data-color="${role.color}">‚úèÔ∏è</button>
            `;

            if (role.managed) {
                li.classList.add('managed');
                li.title = "Managed Role (Bot/Integration)";
            }
            return li;
        }

        function onDragEnd() {
            hasReorderChanges = true;
            updateSaveButtonState();
        }

        function updateSaveButtonState() {
            const hasPending = pendingUpdates.size > 0 || hasReorderChanges;
            saveBtn.disabled = !hasPending;
            if (hasPending) {
                saveBtn.textContent = `üíæ L∆∞u Thay ƒê·ªïi (${pendingUpdates.size} ch·ªânh s·ª≠a + VT)`;
                saveBtn.classList.add('btn-warning');
            } else {
                saveBtn.textContent = 'üíæ L∆∞u C·∫•u Tr√∫c';
                saveBtn.classList.remove('btn-warning');
            }
        }

        // --- EDIT LOGIC ---
        function attachDynamicEvents() {
            // Use event delegation for better performance? For now standard list.
            document.querySelectorAll('.edit-role-btn').forEach(btn => {
                btn.onclick = (e) => {
                    const { id, name, color } = e.target.dataset;
                    // If pending, load pending val
                    let currentName = name;
                    let currentColor = color;
                    if (pendingUpdates.has(id)) {
                        const u = pendingUpdates.get(id);
                        if (u.name) currentName = u.name;
                        if (u.color) currentColor = u.color;
                    }
                    openEditModal(id, currentName, currentColor);
                };
            });
            // ... (keep quick add/toggle same logic) ...
            document.querySelectorAll('.add-role-btn').forEach(btn => {
                btn.onclick = (e) => {
                    const name = prompt("Nh·∫≠p t√™n Role m·ªõi:");
                    if (name) createRole(name, false, e.target);
                };
            });
            document.querySelectorAll('.toggle-btn').forEach(btn => {
                btn.onclick = (e) => {
                    const catId = e.target.dataset.catId;
                    const roleList = document.querySelector(`.role-list[data-cat-id="${catId}"]`);
                    if (roleList) {
                        const isCollapsed = roleList.classList.toggle('collapsed');
                        e.target.textContent = isCollapsed ? '‚ñ∂' : '‚ñº';
                    }
                };
            });
        }

        addCatBtn.onclick = () => {
            const name = prompt("Nh·∫≠p t√™n Ph√¢n M·ª•c m·ªõi:");
            if (name) createRole(name, True, null);
        };

        // --- BATCH SAVE LOGIC ---
        saveBtn.onclick = async () => {
            saveBtn.disabled = true;
            statusMsg.className = '';

            // 1. Gather Updates
            const updates = [];
            pendingUpdates.forEach((val, key) => {
                updates.push({ id: key, ...val });
            });

            // 2. Gather Reorder Structure
            const categories = [];
            document.querySelectorAll('.category-card').forEach(card => {
                const catId = card.dataset.id;
                const isReal = card.dataset.isReal === 'true';
                const roleList = card.querySelector('.role-list');
                const roleIds = [];
                roleList.querySelectorAll('.role-item').forEach(li => {
                    roleIds.push(li.dataset.id);
                });
                categories.push({ id: catId, is_real_category: isReal, role_ids: roleIds });
            });

            try {
                showStatus('‚è≥ ƒêang g·ª≠i y√™u c·∫ßu x·ª≠ l√Ω...', false);

                const res = await fetch('/api/batch/submit', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ updates, reorder: { categories } })
                });

                const data = await res.json();
                if (res.ok && data.task_id) {
                    pollTask(data.task_id);
                } else {
                    showStatus('‚ùå L·ªói g·ª≠i batch: ' + (data.error || "Unknown"), true);
                    saveBtn.disabled = false;
                }
            } catch (err) {
                showStatus('‚ùå L·ªói k·∫øt n·ªëi: ' + err, true);
                saveBtn.disabled = false;
            }
        };

        async function pollTask(taskId) {
            const pollInterval = setInterval(async () => {
                try {
                    const res = await fetch(`/api/batch/status/${taskId}`);
                    const task = await res.json();

                    if (!task || task.error) {
                        clearInterval(pollInterval);
                        showStatus('‚ùå L·ªói ki·ªÉm tra tr·∫°ng th√°i task', true);
                        saveBtn.disabled = false;
                        return;
                    }

                    if (task.status === 'completed') {
                        clearInterval(pollInterval);
                        showStatus('‚úÖ ' + task.message, false);
                        // Reload to reflect all changes clean
                        setTimeout(fetchRoles, 1500);
                    } else if (task.status === 'failed') {
                        clearInterval(pollInterval);
                        showStatus('‚ùå Th·∫•t b·∫°i: ' + task.message, true);
                        saveBtn.disabled = false;
                    } else {
                        // Processing
                        saveBtn.textContent = `‚è≥ ƒêang x·ª≠ l√Ω... ${task.progress}%`;
                        showStatus(`üöÄ ${task.message} (${task.progress}%)`, false);
                    }

                } catch (e) {
                    // Ignore transient network errors during poll
                    console.warn("Poll error", e);
                }
            }, 1000);
        }

        // --- MODAL & LOCAL UPDATE ---
        function openEditModal(id, name, color) {
            currentEditingRoleId = id;
            editName.value = name;
            editColorDecimal.value = color;
            editColorPicker.value = intToHex(Number(color));
            modal.style.display = 'block';
        }

        // Color Sync
        editColorPicker.oninput = (e) => { editColorDecimal.value = hexToInt(e.target.value); }
        editColorDecimal.oninput = (e) => { editColorPicker.value = intToHex(Number(e.target.value)); }
        document.getElementById('modal-cancel').onclick = () => { modal.style.display = 'none'; }

        document.getElementById('modal-save').onclick = () => {
            if (!currentEditingRoleId) return;

            const newName = editName.value;
            const newColor = editColorDecimal.value;

            // Save to pendingUpdates
            pendingUpdates.set(currentEditingRoleId, { name: newName, color: newColor });

            // Update UI immediately (Optimistic UI)
            // Find ALL instances of this role (it might appear once, but valid to check)
            document.querySelectorAll(`.role-item[data-id="${currentEditingRoleId}"]`).forEach(li => {
                const nameSpan = li.querySelector('.role-name');
                const colorSpan = li.querySelector('.role-color');

                nameSpan.textContent = newName + " *";
                colorSpan.style.backgroundColor = intToHex(Number(newColor));

                // Update data attributes
                li.dataset.name = newName;
                li.dataset.color = newColor;

                // Update edit button data
                const btn = li.querySelector('.edit-role-btn');
                if (btn) {
                    btn.dataset.name = newName;
                    btn.dataset.color = newColor;
                }
            });

            modal.style.display = 'none';
            updateSaveButtonState();
            showStatus('‚úé ƒê√£ l∆∞u nh√°p. B·∫•m "L∆∞u Thay ƒê·ªïi" ƒë·ªÉ √°p d·ª•ng l√™n Discord.', false);
        }

        // Helpers
        function intToHex(intColor) {
            if (!intColor) return '#99aab5';
            return '#' + intColor.toString(16).padStart(6, '0');
        }
        function hexToInt(hex) { return parseInt(hex.replace('#', ''), 16); }
        function showStatus(msg, isError) {
            statusMsg.textContent = msg;
            statusMsg.style.color = isError ? '#ff4444' : '#44ff44';
        }

        async function createRole(name, isCategory, targetBtn) {
            // Create is still immediate for now to get ID
            try {
                const res = await fetch('/api/roles/create', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, is_category: isCategory })
                });
                if (res.ok) {
                    showStatus('‚úÖ ƒê√£ t·∫°o role m·ªõi.', false);
                    fetchRoles();
                } else { throw new Error("Failed"); }
            } catch (e) { showStatus('‚ùå L·ªói t·∫°o role', true); }
        }

        // Init
        fetchRoles();
    </script>
</body>

</html>